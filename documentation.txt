Документация, шоб не забыть
	инициализация через функцию parse()В неё параметрами идут дефолтный путь, и мод работы
	
	Да здравствуют модули. Теперь можно импортировать функции отдельно.
		Доступные для импорта:
			func parse();
			class nodeMap(node); возвращает массив со всеми элементами в node идёт как массив элементов типа {body: 			объект, lvl: уровень погружения}
			func setWay(string); Устанавливает дефолтный путь к комп-м. Хз зачем, если в аргументам к парсе это есть, 			потом удалить крч <3 deleted

	Я сделал селекторы ввода, которые найдут марку везде блять,
	это работает так, что можно даже заебашить компонент 2 в компонент 1 и если поставить в компоненте 1 марку компонента 2, то компонент добавится, лол. 

	Теперь система добавления поуровневая, что всё сильно облегчает
	можно добавлять путь каждому элементу.

	Хочу добавить группы компонентов. Группе можно присвоить собственный путь, а компоненту просто ставится метка группы и сё, путь есть.++++
	Ну или можно будет сделать, чтобы в группу просто добавлялись имена компонентов, а потом и путь
	
	Группы готовы. Работают так, как я и сказал. Просто в параметрах к парсе указываешь groups:{
		Тут имя группы : путь к компонентам
		example : './exampleWay/'
	}
	Теперь как аргумент в парсе можно кинуть стринг с путём к json файлу с конфигом. Там пишется всё то же самое, только в стиле json);

	Добавленны сниппеты, работающие в script блоке!
	Добавляются в объекте конфигурации запуска как свойство-объект snippets. Конструкция:
	snippets:{
		snippetKey:"snippetValue"
	}

	Чтобы использовать сниппет надо написать в скрипте ключ снипета между знаков восклицания: !snippetKey!. В процессе
	парсинга конструкция заменится на snippetValue.

	Добавленны шаблоны, или patterns.
	Внешний интерфейс:
		В блоке MU:component указывается атрибут extends = "patternName" и атрибут MUdata = "{jsonObject}".
		В extends указывается имя шаблона, а в MUdata указываются параметры в формате json.
		В конфигурации добавляется свойство-объект patterns:{} в котором имена свойств - имена шаблонов, а значение - путь к mu шаблону.
		patterns:{
			patternName:"./patternWay.mu".
		}
		Путь должен начинаться с ../ or ./ и заканчиваться на .mu
		В самом шаблоне с данные указываются через #. Например, в MUdata указывается "{"simpleKey":"value"}",
		а в самом документе шаблона указывается #simpleKey. В процессе обработки, на стадии fetch #simpleKey заменится на value. Работает это во всём документе, что позволяет очень гибко настраивать его через MUdata.
		Шаблон - это просто обычный MU компонент, но при его обработке будут провидены выше перечисленные изменения. Важно помнить, что scoped работает по имени компонента, а при шаблоне имя сохраняется.
	Добавлена onload функция!
	идёт как свойство onload в конфигурации.
	onload: "onloadFunction()".

	Добавленно управление сжатием кода путём свойства compression. 2 значения: none - сжатие не производится, normal - сжатие происходит в обычном режиме.

	Добавил особый extends self. При таком extend'е не происходит запроса к шаблону, а просто появляется возможность использовать MUdata.

	Добавил поддержку <send></send> из 1й версии. В марке создаётся блок <send></send>. В него вставляются элементы, которые следует отправить. В самом компоненте создаётся пустой елемент <send></send>. В процессе парсинга он будет заменён на содержимое элемента send из марки.