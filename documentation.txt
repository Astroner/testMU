Документация, шоб не забыть
	инициализация через функцию parse()В неё параметрами идут дефолтный путь, и мод работы
	
	Да здравствуют модули. Теперь можно импортировать функции отдельно.
		Доступные для импорта:
			func parse();
			class nodeMap(node); возвращает массив со всеми элементами в node идёт как массив элементов типа {body: 			объект, lvl: уровень погружения}
			func setWay(string); Устанавливает дефолтный путь к комп-м. Хз зачем, если в аргументам к парсе это есть, 			потом удалить крч <3 deleted

	Я сделал селекторы ввода, которые найдут марку везде блять,
	это работает так, что можно даже заебашить компонент 2 в компонент 1 и если поставить в компоненте 1 марку компонента 2, то компонент добавится, лол. 

	Теперь система добавления поуровневая, что всё сильно облегчает
	можно добавлять путь каждому элементу.

	Хочу добавить группы компонентов. Группе можно присвоить собственный путь, а компоненту просто ставится метка группы и сё, путь есть.++++
	Ну или можно будет сделать, чтобы в группу просто добавлялись имена компонентов, а потом и путь
	
	Группы готовы. Работают так, как я и сказал. Просто в параметрах к парсе указываешь groups:{
		Тут имя группы : путь к компонентам
		example : './exampleWay/'
	}
	Теперь как аргумент в парсе можно кинуть стринг с путём к json файлу с конфигом. Там пишется всё то же самое, только в стиле json);

	Добавленны сниппеты, работающие в script блоке!
	Добавляются в объекте конфигурации запуска как свойство-объект snippets. Конструкция:
	snippets:{
		snippetKey:"snippetValue"
	}

	Чтобы использовать сниппет надо написать в скрипте ключ снипета между знаков восклицания: !snippetKey!. В процессе
	парсинга конструкция заменится на snippetValue.

	Добавленны шаблоны, или patterns.
	Внешний интерфейс:
		В блоке MU:component указывается атрибут extends = "patternName" и атрибут MUdata = "{jsonObject}".
		В extends указывается имя шаблона, а в MUdata указываются параметры в формате json.
		В конфигурации добавляется свойство-объект patterns:{} в котором имена свойств - имена шаблонов, а значение - путь к mu шаблону.
		patterns:{
			patternName:"./patternWay.mu".
		}
		Путь должен начинаться с ../ or ./ и заканчиваться на .mu
		В самом шаблоне с данные указываются через #. Например, в MUdata указывается "{"simpleKey":"value"}",
		а в самом документе шаблона указывается #simpleKey. В процессе обработки, на стадии fetch #simpleKey заменится на value. Работает это во всём документе, что позволяет очень гибко настраивать его через MUdata.
		Шаблон - это просто обычный MU компонент, но при его обработке будут провидены выше перечисленные изменения. Важно помнить, что scoped работает по имени компонента, а при шаблоне имя сохраняется.
	Добавлена onload функция!
	идёт как свойство onload в конфигурации.
	onload: "onloadFunction()".

	Добавленно управление сжатием кода путём свойства compression. 2 значения: none - сжатие не производится, normal - сжатие происходит в обычном режиме.

	Добавил особый extends self. При таком extend'е не происходит запроса к шаблону, а просто появляется возможность использовать MUdata.

	Добавил поддержку <send></send> из 1й версии. В марке создаётся блок <send></send>. В него вставляются элементы, которые следует отправить. В самом компоненте создаётся пустой елемент <send></send>. В процессе парсинга он будет заменён на содержимое элемента send из марки.

Добавил support библиотеку MU0.1support.js и её минифицированную копию.
В ней пока только функция для суппортив вещей, которые нужны в процессе функционирования сайта.
Функция asyncComponent() принимает 4 параметра way, data, send и success. 
way - путь у компоненту,
data - аналог MUdata. data это объект с данными, которые передаются.
success - функция, которая сработает, когда закончится компиляция компонента, который будет в неё передан.
send - массив узлов, которые будут вставленны на место send в компоненте.
ПРИМЕР:
let tes = document.createElement("div");
tes.innerHTML = "i'm sended!"
asyncComponent({
	way:"./components/test.mu",
	data:{
		1:"i'm first",
		2:"i'm second"
	},
	send:[tes],
	success: function (body) {
		document.body.appendChild(body);
	}
});

Добавил элемент логики в компонент для умных замен зерез MUdata
Со стороны инициализации компонента всё так же. Со стороны создания компонента есть различия.

В конце компонента, после всех блоков пишется ">>logic", после чего идут блоки логики для MUdata.
Для свойства example создаётся элемент <var:example></var:example>. В него записываются блоки с case'ами и 
блок default, если ни один case не подошёл.
Для значения Aiaia свойства example создаётся элемент <case:Aiaia></case:Aiaia>, в который записывается
значение, которое будет выводиться вместо значения Aiaia на место флага #example. Во внутренности 
<case:Aiaia></case:Aiaia> может записываться token {data}, на место которого подставиться значение, переданное в exaple, в данном случае Aiaia.
В блок <default></default> записывается значение, если ни один case не подошёл. В нём также присутствует {data}, что позволяет обрабатывать значение.
ПРИМЕР:

>>logic
<var:1>
	<case:effer>
		Здесь стоит {data}
	</case:effer>
	<case:2>Теперь значение 2</case:2>
	<default>
		Значения {data} нет!
	</default>
</var1>
<var:2>
	<case:second1>
		Теперь я заменил {data}
	</case:second1>
</var:2> 