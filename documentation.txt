Инициализация через функцию parse() В неё параметрами идут дефолтный путь, и мод работы

import parse from './way';
parse({
	way:"./components/",
	mode:"def"
});

	class nodeMap(node); возвращает массив со всеми элементами в node идёт как массив элементов типа {body: объект, lvl: уровень погружения}

	Теперь система добавления поуровневая, что всё сильно облегчает
	можно добавлять путь каждому элементу.

	Хочу добавить группы компонентов. Группе можно присвоить собственный путь, а компоненту просто ставится метка группы и сё, путь есть.++++
	Ну или можно будет сделать, чтобы в группу просто добавлялись имена компонентов, а потом и путь
	
	Группы готовы. Работают так, как я и сказал. Просто в параметрах к parse указываешь groups:{
		Тут имя группы : путь к компонентам
		example : './exampleWay/'
	}
	Теперь как аргумент в parse можно кинуть стринг с путём к json файлу с конфигом. Там пишется всё то же самое, только в стиле json);

	Добавленны сниппеты, работающие в script блоке!
	Добавляются в объекте конфигурации запуска как свойство-объект snippets. Конструкция:
	snippets:{
		snippetKey:"snippetValue"
	}

	Чтобы использовать сниппет надо написать в скрипте ключ снипета между знаков восклицания: !snippetKey!. В процессе
	парсинга конструкция заменится на snippetValue.

	Добавленны шаблоны, или patterns.
	Внешний интерфейс:
		В блоке MU:component указывается атрибут extends = "patternName" и атрибут MUdata = "{jsonObject}".
		В extends указывается имя шаблона, а в MUdata указываются параметры в формате json.
		В конфигурации добавляется свойство-объект patterns:{} в котором имена свойств - имена шаблонов, а значение - путь к mu шаблону.
		patterns:{
			patternName:"./patternWay.mu".
		}
		Путь должен начинаться с ../ or ./ и заканчиваться на .mu
		В самом шаблоне с данные указываются через #. Например, в MUdata указывается "{"simpleKey":"value"}",
		а в самом документе шаблона указывается #simpleKey. В процессе обработки, на стадии fetch #simpleKey заменится на value. Работает это во всём документе, что позволяет очень гибко настраивать его через MUdata.
		Шаблон - это просто обычный MU компонент, но при его обработке будут провидены выше перечисленные изменения. Важно помнить, что scoped работает по имени компонента, а при шаблоне имя сохраняется.
	Добавлена onload функция!
	идёт как свойство onload в конфигурации.
	onload: "onloadFunction()".

	Добавленно управление сжатием кода путём свойства compression. 2 значения: none - сжатие не производится, normal - сжатие происходит в обычном режиме.

	Добавил особый extends self. При таком extend'е не происходит запроса к шаблону, а просто появляется возможность использовать MUdata.

	Добавил поддержку <send></send> из 1й версии. В марке создаётся блок <send></send>. В него вставляются элементы, которые следует отправить. В самом компоненте создаётся пустой елемент <send></send>. В процессе парсинга он будет заменён на содержимое элемента send из марки.

Добавил support библиотеку MU0.1support.js и её минифицированную копию.
В ней пока только функция для суппортив вещей, которые нужны в процессе функционирования сайта.
Функция asyncComponent() принимает 4 параметра way, data, send и success. 
way - путь у компоненту,
data - аналог MUdata. data это объект с данными, которые передаются.
success - функция, которая сработает, когда закончится компиляция компонента, который будет в неё передан.
send - массив узлов, которые будут вставленны на место send в компоненте.
ПРИМЕР:
let tes = document.createElement("div");
tes.innerHTML = "i'm sended!"
asyncComponent({
	way:"./components/test.mu",
	data:{
		1:"i'm first",
		2:"i'm second"
	},
	send:[tes],
	success: function (body) {
		document.body.appendChild(body);
	}
});

Добавил элемент логики в компонент для умных замен зерез MUdata
Со стороны инициализации компонента всё так же. Со стороны создания компонента есть различия.

В конце компонента, после всех блоков пишется ">>logic", после чего идут блоки логики для MUdata.
Для свойства example создаётся элемент <var:example></var:example>. В него записываются блоки с case'ами и 
блок default, если ни один case не подошёл.
Для значения Aiaia свойства example создаётся элемент <case:Aiaia></case:Aiaia>, в который записывается
значение, которое будет выводиться вместо значения Aiaia на место флага #example. Во внутренности 
<case:Aiaia></case:Aiaia> может записываться token {data}, на место которого подставиться значение, переданное в exaple, в данном случае Aiaia.
В блок <default></default> записывается значение, если ни один case не подошёл. В нём также присутствует {data}, что позволяет обрабатывать значение.
ПРИМЕР:

>>logic
<var:1>
	<case:effer>
		Здесь стоит {data}
	</case:effer>
	<case:2>Теперь значение 2</case:2>
	<default>
		Значения {data} нет!
	</default>
</var1>
<var:2>
	<case:second1>
		Теперь я заменил {data}
	</case:second1>
</var:2> 
Добавил ту же фичу в asyncComponent. Теперья для обращения к suppot функциям необходимо обращаться к msup, например musp.asyncComponent( {} )
К support добавил функции loadComp, getList и loadedComp. Также переименовал asyncComponent в asyncComp
loadComp() Принимает объект со свойствами name и way.
name - имя компонента, по которому в будущем будет доступен сам компонент
way - путь для загрузки компонента.
ПРИМЕР:
msup.loadComp({
	name:"test",
	way:"./components/test.mu"
});

getList() - Не принимает параметров, возвращает список имён загруженных компонентов
ПРИМЕР:
console.log(msup.getList())//["test"]

loadedComp() - возвращает Скомпилированный компонент. 
Принимает:
name - имя компонента,
data - data, которую необходимо вставить
send - массив элементов, который будет вставлен вместо блока send
ПРИМЕР:
let comp = msup.loadedComp({
	name:"test",
	data:{
		1:"2",
		2:"1"
	},
	send:[tes],
})

Добавил функцию msup.subscribe(callback); Выполняет callback при загрузке нового компонента через loadComp.
В callback передаётся имя загруженного компонента и копия массива загруженных компонентов сразу после загрузки.
ПРИМЕР:
msup.subscribe(function (name, state) {
	if (state.length==2) {
		console.log(name);
	}
});

Теперь в функцию msup.loadComp() можно передать несколько объектов для загрузки.
ПРЕМЕР:
msup.loadComp({
	name:"dom",
	way:"components/test.mu"
},
{
	name:"scr",
	way:"components/script.mu"
});